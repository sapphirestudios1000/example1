/* Generated By:JavaCC: Do not edit this line. FOM.java */
package org.portico.impl.hla13.fomparser;

import org.portico.impl.HLAVersion;
import org.portico.lrc.compat.JCouldNotOpenFED;
import org.portico.lrc.compat.JErrorReadingFED;
import org.portico.lrc.model.ACMetadata;
import org.portico.lrc.model.ICMetadata;
import org.portico.lrc.model.OCMetadata;
import org.portico.lrc.model.ObjectModel;
import org.portico.lrc.model.Order;
import org.portico.lrc.model.Space;
import org.portico.lrc.model.Transport;
import org.portico.lrc.model.datatype.NaType;

import java.io.InputStream;
import java.net.URL;

public class FOM implements FOMConstants
{
	public static ObjectModel parseFOM( URL fom ) throws JCouldNotOpenFED, JErrorReadingFED
	{
		if( fom == null )
		{
			throw new JCouldNotOpenFED( "Null FOM given to Parser" );
		}

		// open the stream
		InputStream istream = null;
		try
		{
			istream = fom.openStream();
		}
		catch( Exception e )
		{
			throw new JCouldNotOpenFED( "Error opening [" + fom + "]: " + e.getMessage() );
		}

		ObjectModel model = parseFOM( istream );
		model.setFileName( fom.toString() );
		return model;
	}

	public static ObjectModel parseFOM( InputStream istream ) throws JCouldNotOpenFED,
	    JErrorReadingFED
	{
		// check for a valid URL
		if( istream == null )
		{
			throw new JCouldNotOpenFED( "Null FOM given to Parser" );
		}

		// parse the FOM
		try
		{
			// create the parser
			FOM parser = new FOM( istream );
			// create the model to populate
			ObjectModel theModel = new ObjectModel( HLAVersion.HLA13 );
			// run the parser
			parser.parse( theModel );
			// lock the model
			theModel.lock();
			// mommify the thing
			ObjectModel.mommify( theModel );
			// return the model
			return theModel;
		}
		catch( Throwable e )
		{
			throw new JErrorReadingFED( "Error reading FED file [" + istream + "]: " +
			                            e.getMessage(), e );
		}
		finally
		{
			try
			{
				istream.close();
			}
			catch( Exception e )
			{ /* do nothing */
			}
		}
	}

/* attribute/parameter elements
 TOKEN :
 {
 < TRANSPORT: "reliable" | "best_effort" >
 | < ORDER: "timestamp" | "receive" >
 }
 */
	/**********************************************/
	/************** Main Productions **************/
	/**********************************************/
	final public void parse( ObjectModel theModel ) throws ParseException
	{
		jj_consume_token( FED );
		federation();
		fedVersion();
		label_1: while( true )
		{
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case SPACES:
				case OBJECTS:
				case INTERACTIONS:
					;
					break;
				default:
					jj_la1[0] = jj_gen;
					break label_1;
			}
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case SPACES:
					spaces( theModel );
					break;
				case OBJECTS:
					objects( theModel );
					break;
				case INTERACTIONS:
					interactions( theModel );
					break;
				default:
					jj_la1[1] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
			}
		}
		jj_consume_token( P_CLOSE );
		jj_consume_token( 0 );
	}

	/*****************************/
	/*** Element: "Federation" ***/
	/*****************************/
	final public void federation() throws ParseException
	{
		jj_consume_token( FEDERATION );
		jj_consume_token( STRING );
		jj_consume_token( P_CLOSE );
	}

	/*****************************/
	/*** Element: "FEDversion" ***/
	/*****************************/
/* Must be "1.3" */
	final public void fedVersion() throws ParseException
	{
		jj_consume_token( FEDVERSION );
		switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
		{
			case 21:
				jj_consume_token( 21 );
				break;
			case 22:
				jj_consume_token( 22 );
				break;
			default:
				jj_la1[2] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
		}
		jj_consume_token( P_CLOSE );
	}

	/*************************** ROUTING SPACE PRODUCTIONS ***************************/
	final public void spaces( ObjectModel theModel ) throws ParseException
	{
		jj_consume_token( SPACES );
		label_2: while( true )
		{
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case SPACE:
					;
					break;
				default:
					jj_la1[3] = jj_gen;
					break label_2;
			}
			space( theModel );
		}
		jj_consume_token( P_CLOSE );
	}

	final public void space( ObjectModel theModel ) throws ParseException
	{
		Space theSpace = null;
		jj_consume_token( SPACE );
		theSpace = theModel.newSpace( stringValue() );
		label_3: while( true )
		{
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case DIMENSION:
					;
					break;
				default:
					jj_la1[4] = jj_gen;
					break label_3;
			}
			dimension( theModel, theSpace );
		}
		jj_consume_token( P_CLOSE );
		theModel.addSpace( theSpace );
	}

	final public void dimension( ObjectModel theModel, Space theSpace ) throws ParseException
	{
		jj_consume_token( DIMENSION );
		theSpace.addDimension( theModel.newDimension( stringValue() ) );
		jj_consume_token( P_CLOSE );
	}

	/*************************** OBJECT CLASS PRODUCTIONS ***************************/
	final public void objects( ObjectModel theModel ) throws ParseException
	{
		jj_consume_token( OBJECTS );
		label_4: while( true )
		{
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case CLASS:
					;
					break;
				default:
					jj_la1[5] = jj_gen;
					break label_4;
			}
			objectClass( theModel, null );
		}
		jj_consume_token( P_CLOSE );
	}

	final public void objectClass( ObjectModel theModel, OCMetadata parent ) throws ParseException
	{
		OCMetadata theObject = null;
		jj_consume_token( CLASS );
		theObject = theModel.newObject( stringValue() );
		label_5: while( true )
		{
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case CLASS:
				case ATTRIBUTE:
					;
					break;
				default:
					jj_la1[6] = jj_gen;
					break label_5;
			}
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case ATTRIBUTE:
					objectAttribute( theObject, theModel );
					break;
				case CLASS:
					objectClass( theModel, theObject );
					break;
				default:
					jj_la1[7] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
			}
		}
		jj_consume_token( P_CLOSE );
		// check to see if we have a parent
		if( parent == null )
		{
			// no parent, make sure we are ObjectRoot
			if( theObject.getLocalName().equals( "ObjectRoot" ) == false )
			{
				// NO PARENT AND NOT OBJECT ROOT! EXCEPTION!!!!
				{
					if( true )
						throw new ParseException( "First object class must be ObjectRoot" );
				}
			}
			else
			{
				// we are object root, add us and set us as the root
				theModel.addObjectClass( theObject );
				theModel.setObjectRoot( theObject );
			}
		}
		else
		{
			// we do have a parent, set it up and add us to the model
			theObject.setParent( parent );
			theModel.addObjectClass( theObject );
		}
	}

	final public void objectAttribute( OCMetadata theClass, ObjectModel theModel )
	    throws ParseException, ParseException
	{
		ACMetadata attribute = null;
		Transport transport = null;
		Order order = null;
		String spaceName = null;
		jj_consume_token( ATTRIBUTE );
		attribute = theModel.newAttribute( stringValue(), NaType.INSTANCE );
		transport = transport();
		order = order();
		switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
		{
			case STRING:
				spaceName = stringValue();
				break;
			default:
				jj_la1[8] = jj_gen;
				;
		}
		jj_consume_token( P_CLOSE );
		attribute.setOrder( order );
		attribute.setTransport( transport );
		theClass.addAttribute( attribute );
		if( spaceName != null )
		{
			// find the space and add the link to the attribute metadata
			// if we can't find it, throw an exception
			Space theSpace = theModel.getSpace( spaceName );
			if( theSpace != null )
			{
				attribute.setSpace( theSpace );
			}
			else
			{
				String attName =
				    "ObjectRoot." + theClass.getLocalName() + "." + attribute.getName();
				{
					if( true )
						throw new ParseException( "attribute [" + attName +
						                          "] uses undefined space \"" + spaceName + "\"" );
				}
			}
		}
	}

	/************************* INTERACTION CLASS PRODUCTIONS ************************/
	final public void interactions( ObjectModel theModel ) throws ParseException
	{
		jj_consume_token( INTERACTIONS );
		label_6: while( true )
		{
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case CLASS:
					;
					break;
				default:
					jj_la1[9] = jj_gen;
					break label_6;
			}
			interactionClass( theModel, null );
		}
		jj_consume_token( P_CLOSE );
	}

	final public void interactionClass( ObjectModel theModel, ICMetadata parent )
	    throws ParseException
	{
		ICMetadata theInteraction = null;
		Transport transport = null;
		Order order = null;
		String spaceName = null;
		jj_consume_token( CLASS );
		theInteraction = theModel.newInteraction( stringValue() );
		transport = transport();
		order = order();
		switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
		{
			case STRING:
				spaceName = stringValue();
				break;
			default:
				jj_la1[10] = jj_gen;
				;
		}
		label_7: while( true )
		{
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case CLASS:
				case PARAMETER:
					;
					break;
				default:
					jj_la1[11] = jj_gen;
					break label_7;
			}
			switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
			{
				case PARAMETER:
					interactionParameter( theInteraction, theModel );
					break;
				case CLASS:
					interactionClass( theModel, theInteraction );
					break;
				default:
					jj_la1[12] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
			}
		}
		jj_consume_token( P_CLOSE );
		// set the order and transport
		theInteraction.setTransport( transport );
		theInteraction.setOrder( order );

		// if we have a space name, add it to the metadata
		if( spaceName != null )
		{
			// find the space and add the link to the interaction metadata
			// if we can't find it, throw an exception
			Space theSpace = theModel.getSpace( spaceName );
			if( theSpace != null )
			{
				theInteraction.setSpace( theSpace );
			}
			else
			{
				{
					if( true )
						throw new ParseException( "interaction [InteractionRoot." +
						                          theInteraction.getLocalName() +
						                          "] uses undefined space: \"" + spaceName + "\"" );
				}
			}
		}

		if( parent == null )
		{
			// no parent - this must be InteractionRoot - verify
			if( theInteraction.getQualifiedName().equals( "InteractionRoot" ) == false )
			{
				// NO PARENT AND NOT INTERACTION ROOT! THROW EXCEPTION!!!!
				{
					if( true )
						throw new ParseException( "First interaction class must be InteractionRoot" );
				}
			}
			else
			{
				// it is interaction root, add it to the model and set it as the root
				theModel.addInteractionClass( theInteraction );
				theModel.setInteractionRoot( theInteraction );
			}
		}
		else
		{
			// we do have a parent, set it up and add us to the model
			theInteraction.setParent( parent );
			theModel.addInteractionClass( theInteraction );
		}
	}

	final public void interactionParameter( ICMetadata theInteraction, ObjectModel theModel )
	    throws ParseException
	{
		jj_consume_token( PARAMETER );
		theInteraction.addParameter( theModel.newParameter(stringValue(), NaType.INSTANCE) );
		jj_consume_token( P_CLOSE );
	}

	/**************************** SUPPORTING PRODUCTIONS ****************************/
	final public Transport transport() throws ParseException
	{
		switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
		{
			case 23:
				jj_consume_token( 23 );
				{
					if( true )
						return Transport.RELIABLE;
				}
				break;
			case 24:
				jj_consume_token( 24 );
				{
					if( true )
						return Transport.BEST_EFFORT;
				}
				break;
			default:
				jj_la1[13] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}

	final public Order order() throws ParseException
	{
		switch( (jj_ntk == -1) ? jj_ntk() : jj_ntk )
		{
			case 25:
				jj_consume_token( 25 );
				{
					if( true )
						return Order.TIMESTAMP;
				}
				break;
			case 26:
				jj_consume_token( 26 );
				{
					if( true )
						return Order.RECEIVE;
				}
				break;
			default:
				jj_la1[14] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}

	final public String stringValue() throws ParseException
	{
		Token token;
		token = jj_consume_token( STRING );
		{
			if( true )
				return token.image;
		}
		throw new Error( "Missing return statement in function" );
	}

	public FOMTokenManager token_source;
	SimpleCharStream jj_input_stream;
	public Token token, jj_nt;
	private int jj_ntk;
	private int jj_gen;
	final private int[] jj_la1 = new int[15];
	static private int[] jj_la1_0;
	static
	{
		jj_la1_0();
	}

	private static void jj_la1_0()
	{
		jj_la1_0 =
		    new int[]{ 0x92000, 0x92000, 0x600000, 0x4000, 0x8000, 0x20000, 0x60000, 0x60000,
		              0x8000000, 0x20000, 0x8000000, 0x120000, 0x120000, 0x1800000, 0x6000000, };
	}

	public FOM( java.io.InputStream stream )
	{
		this( stream, null );
	}

	public FOM( java.io.InputStream stream, String encoding )
	{
		try
		{
			jj_input_stream = new SimpleCharStream( stream, encoding, 1, 1 );
		}
		catch( java.io.UnsupportedEncodingException e )
		{
			throw new RuntimeException( e );
		}
		token_source = new FOMTokenManager( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 15; i++ )
			jj_la1[i] = -1;
	}

	public void ReInit( java.io.InputStream stream )
	{
		ReInit( stream );
	}

	public void ReInit( java.io.InputStream stream, String encoding )
	{
		try
		{
			jj_input_stream.ReInit( stream, encoding, 1, 1 );
		}
		catch( java.io.UnsupportedEncodingException e )
		{
			throw new RuntimeException( e );
		}
		token_source.ReInit( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 15; i++ )
			jj_la1[i] = -1;
	}

	public FOM( java.io.Reader stream )
	{
		jj_input_stream = new SimpleCharStream( stream, 1, 1 );
		token_source = new FOMTokenManager( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 15; i++ )
			jj_la1[i] = -1;
	}

	public void ReInit( java.io.Reader stream )
	{
		jj_input_stream.ReInit( stream, 1, 1 );
		token_source.ReInit( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 15; i++ )
			jj_la1[i] = -1;
	}

	public FOM( FOMTokenManager tm )
	{
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 15; i++ )
			jj_la1[i] = -1;
	}

	public void ReInit( FOMTokenManager tm )
	{
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 15; i++ )
			jj_la1[i] = -1;
	}

	final private Token jj_consume_token( int kind ) throws ParseException
	{
		Token oldToken;
		if( (oldToken = token).next != null )
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if( token.kind == kind )
		{
			jj_gen++;
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	final public Token getNextToken()
	{
		if( token.next != null )
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}

	final public Token getToken( int index )
	{
		Token t = token;
		for( int i = 0; i < index; i++ )
		{
			if( t.next != null )
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	final private int jj_ntk()
	{
		if( (jj_nt = token.next) == null )
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
	private int[] jj_expentry;
	private int jj_kind = -1;

	public ParseException generateParseException()
	{
		jj_expentries.removeAllElements();
		boolean[] la1tokens = new boolean[32];
		for( int i = 0; i < 32; i++ )
		{
			la1tokens[i] = false;
		}
		if( jj_kind >= 0 )
		{
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for( int i = 0; i < 15; i++ )
		{
			if( jj_la1[i] == jj_gen )
			{
				for( int j = 0; j < 32; j++ )
				{
					if( (jj_la1_0[i] & (1 << j)) != 0 )
					{
						la1tokens[j] = true;
					}
				}
			}
		}
		for( int i = 0; i < 32; i++ )
		{
			if( la1tokens[i] )
			{
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.addElement( jj_expentry );
			}
		}
		int[][] exptokseq = new int[jj_expentries.size()][];
		for( int i = 0; i < jj_expentries.size(); i++ )
		{
			exptokseq[i] = (int[])jj_expentries.elementAt( i );
		}
		return new ParseException( token, exptokseq, tokenImage );
	}

	final public void enable_tracing()
	{
	}

	final public void disable_tracing()
	{
	}

}
